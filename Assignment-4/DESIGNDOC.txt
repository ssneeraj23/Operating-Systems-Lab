DESIGN DOC
Group 32
Project Contributors: Mohan Kishore Chilukuri         
                      Aditya Pandiri         
                      Gitanjali Gupta         
                      Neeraj Boddeda

MAIN THREAD:
This thread is the main thread where all the initialisation gets done. The  graph is read from the file and placed in an adjacency list. The common nodes number between any nodes are precomputed and stored here. Nodes are given priority bit randomly. The threads of pushUpdate, userSimulator are initialised and joined to the main thread here.


DATA STRUCTURES USED:
Adjacency list to store the graph is a vector of vectors using stl library. The actions have a struct which contains the user id of the node which generated the action, action id, type of the action, timestamp and the priority of the action.The nodes in the graph have two queues namely feed and wall queue. It also contains the count of the number of likes, comments, post actions generated previously. Wall is a normal stl queue which stores actions that are generated by userSimulator thread. Feed queue is a priority queue which decides priority based on the priority bit.The maximum size of feed queue that is possible is 10682.List of all the nodes are stored in a vector and any modifications to any of the queues are done on this.


DESIGN OF LOCKS:
This is the main single threaded process which has different threads attached to it so it doesn't require any locks.




USER SIMULATOR:
This thread selects 100 random nodes and generates actions randomly based on the conditions given for each of the 100 nodes. It pushes the actions into the wall queue of the respective node. Number of actions generated for each node is proportional to the degree of each node is proportional to the degree of that node as 10(1+log2(degree of node)). 
Every node generated is written into the “sns.log” file with its degree and number of actions generated by it. Every generated action by all nodes are pushed into this queue which are accessed by the pushUpdate threads. When an action is pushed into the monitor queue, its id, type,timestamp are written into the “sns.log” file.


DATA STRUCTURES USED:
Monitor queue is a stl queue which has actions in it. To avoid duplicates we use a set to generate 100 random nodes and then store them in a vector generated which stores the ids of the randomly selected nodes. 


DESIGN OF LOCKS:


Monitor queue is populated by userSimulator and is popped by pushUpdate. So, we need to maintain a mutex and make the push into the monitor queue atomic. Here, we need a pthread mutex lock. We also need to broadcast to other threads that this push is done.We use pthread_cond_broadcast for that.


PUSH UPDATE:
Here the monitor queue hints when it has been updated (using pthread_cond_signal() func) and then the feed queues are being updated from the monitor queue.


DATA STRUCTURE USED:
Monitor queue is a normal stl queue, and every node has a data member of name feed, which is a stl priority_queue to ensure that things entered come in priority order. Since the comparison can be on the basis of chronology or priority, we have made a special comparator, which ensures that depending on the priority bit of the nodes, we make their respective feed queues in that order. 


RATIONALIZING DESIGN DECISION FOR QUEUE SIZE:
We used stl queues, and the number of nodes added per user simulation process awake time does not cross the max limit size of this container(max degree encountered for a node in the graph is 7400) . Plus, readPost and pushUpdate will keep dequeuing the feed queues and monitor queue respectively.




DESIGN OF LOCKS:
Locks are mainly used to start the pushing of actions into the feed queues as soon as the monitor queue is updated. Also, locks are used to make certain processes atomic(like the push and pop of queues)(PROCESS SYNCHRONISATION).
A mutex lock is acquired and the thread waits on the condition variable to be signalled, indicating the update of the monitor queue. After the signal is received, we release this lock and the pushUpdate starts. Since the popping and pushing of queues is not atomic, to avoid this race condition, we put mutex locks over them. Also when an action is added into a node’s feed queue, a signal is sent, indicating the updation of neighbours feed queue, which should automatically start the readPost threads (who start dequeuing the feed queues).


READ POST:
Here the dequeuing of feed queues starts when it has been updated (using pthread_cond_signal() func) and then accordingly prints messages.


DATA STRUCTURE USED:
The node number for which the feed queue is updated is dequeued from the read queue. The feed queue of the node dequeued in the previous step, is read and dequeued, and a message is printed in the terminal.


RATIONALIZING DESIGN DECISION FOR QUEUE SIZE:
We used stl queues, and the number of nodes added per pushUpdate process awake time does not cross the max limit size of this container( the max number of actions added at a time would be 100). Plus, readPost dequeuing the feed queues of the updated nodes.




DESIGN OF LOCKS:
Initially, a lock is used while dequeuing the node number whose feed queue is updated from the read queue. With the help of this lock, the read queue can only be accessed at once either in one of the pushUpdate threads or readPost threads. Also, some more locks are  used to start the dequeueing of actions from the feed queues as soon as they are updated. Also, push and pop are made atomic.
Remaining process is similar to what we did pushUpdate.

Justification for concurrency:
When an action is added to monitor queue, it broadcasts signals and one of the push Update threads receive it and pops the action and then user simulator can
keep on adding more actions during which push update threads can add the popped action into feed queues. While the addition of acitons to feed queues are
done by pushupdates they send signals to read post threads and they pop these actions out of the modified feed queues. Readpost threads can know which nodes 
feed is modified by looking into the read queue. When this happens user simulator and other push update  threads can work simultaneously as they are not waiting for any locks used by read post. This can also be seen in the log file as statements from user simulator, push updates and read post are coming very closely.
